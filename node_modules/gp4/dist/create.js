import { setTimeout as delay } from 'node:timers/promises';
import is, { assert } from '@sindresorhus/is';
import asPromise from './as-promise/index.js';
import Request from './core/index.js';
import Options from './core/options.js';
const isGp4Instance = (value) => is.function(value);
const aliases = ['get', 'post', 'put', 'patch', 'head', 'delete'];

export default function create(defaults) {
    defaults = {
        options: new Options(undefined, undefined, defaults.options),
        handlers: [...defaults.handlers],
        mutableDefaults: defaults.mutableDefaults,
    };
    Object.defineProperty(defaults, 'mutableDefaults', {
        enumerable: true,
        configurable: false,
        writable: false,
    });
    const gp4 = ((url, options, defaultOptions = defaults.options) => {
        const request = new Request(url, options, defaultOptions);
        let promise;
        const lastHandler = (normalized) => {
            request.options = normalized;
            request._noPipe = !normalized?.isStream;
            request.flush();
            return normalized?.isStream ? request : (promise ||= asPromise(request));
        };
        let iteration = 0;
        const iterateHandlers = (newOptions) => {
            const handler = defaults.handlers[iteration++] ?? lastHandler;
            const result = handler(newOptions, iterateHandlers);
            return is.promise(result) && !request.options?.isStream
                ? (promise ||= asPromise(request), 
                   Object.defineProperties(result, Object.fromEntries(
                       Object.entries(Object.getOwnPropertyDescriptors(promise))
                           .filter(([key]) => !(key in result))
                   )), 
                   result.cancel = promise.cancel, 
                   result)
                : result;
        };
        return iterateHandlers(request.options);
    });
    gp4.extend = (...instancesOrOptions) => {
        const options = new Options(undefined, undefined, defaults.options);
        const handlers = [...defaults.handlers];
        let mutableDefaults;
        for (const value of instancesOrOptions) {
            isGp4Instance(value)
                ? (options.merge(value.defaults.options), 
                   handlers.push(...value.defaults.handlers), 
                   mutableDefaults = value.defaults.mutableDefaults)
                : (options.merge(value), 
                   value.handlers && handlers.push(...value.handlers), 
                   mutableDefaults = value.mutableDefaults);
        }
        return create({
            options,
            handlers,
            mutableDefaults: Boolean(mutableDefaults),
        });
    };
    const paginateEach = (async function* (url, options) {
        let normalizedOptions = new Options(url, options, defaults.options);
        normalizedOptions.resolveXOnly = false;
        const { pagination } = normalizedOptions;
        assert.function(pagination.transform);
        assert.function(pagination.shouldContinue);
        assert.function(pagination.filter);
        assert.function(pagination.paginate);
        assert.number(pagination.countLimit);
        assert.number(pagination.requestLimit);
        assert.number(pagination.backoff);
        const allItems = [];
        let { countLimit } = pagination;
        let numberOfRequests = 0;
        while (numberOfRequests < pagination.requestLimit) {
            numberOfRequests !== 0 && (await delay(pagination.backoff));
            const response = (await gp4(undefined, undefined, normalizedOptions));
            const parsed = await pagination.transform(response);
            const currentItems = [];
            assert.array(parsed);
            for (const item of parsed) {
                if (pagination.filter({ item, currentItems, allItems })) {
                    if (!pagination.shouldContinue({ item, currentItems, allItems })) {
                        return;
                    }
                    yield item;
                    pagination.stackAllItems && allItems.push(item);
                    currentItems.push(item);
                    if (--countLimit <= 0) {
                        return;
                    }
                }
            }
            const optionsToMerge = pagination.paginate({
                response,
                currentItems,
                allItems,
            });
            if (optionsToMerge === false) {
                return;
            }
            normalizedOptions = optionsToMerge === response.request.options 
                ? response.request.options 
                : (options.merge(optionsToMerge), 
                   assert.any([is.urlInstance, is.undefined], optionsToMerge.url),
                   optionsToMerge.url !== undefined && (normalizedOptions.prefixUrl = '', normalizedOptions.url = optionsToMerge.url),
                   normalizedOptions);
            numberOfRequests++;
        }
    });
    gp4.paginate = paginateEach;
    gp4.paginate.all = (async (url, options) => {
        const results = [];
        for await (const item of paginateEach(url, options)) {
            results.push(item);
        }
        return results;
    });
    gp4.paginate.each = paginateEach;
    gp4.stream = ((url, options) => gp4(url, { ...options, isStream: true }));
    for (const method of aliases) {
        gp4[method] = ((url, options) => gp4(url, { ...options, method }));
        gp4.stream[method] = ((url, options) => gp4(url, { ...options, method, isStream: true }));
    }
    !defaults.mutableDefaults && (Object.freeze(defaults.handlers), defaults.options.freeze());
    Object.defineProperty(gp4, 'defaults', {
        value: defaults,
        writable: false,
        configurable: false,
        enumerable: true,
    });
    return gp4;
};