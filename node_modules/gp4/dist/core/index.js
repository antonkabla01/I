import process from 'node:process';
import { Buffer } from 'node:buffer';
import { Duplex } from 'node:stream';
import http, { ServerResponse } from 'node:http';
import timer from '@szmarczak/http-timer';
import CacheableRequest, { CacheError as CacheableCacheError, } from 'cacheable-request';
import decompressResponse from 'decompress-response';
import is, { isBuffer } from '@sindresorhus/is';
import { FormDataEncoder, isFormData as isFormDataLike } from 'form-data-encoder';
import getXSize from './utils/get-x-size.js';
import isFormData from './utils/is-form-data.js';
import proxyEvents from './utils/proxy-events.js';
import timedOut, { TimeoutError as TimedOutTimeoutError } from './timed-out.js';
import urlToOptions from './utils/url-to-options.js';
import WeakableMap from './utils/weakable-map.js';
import calculateRetryDelay from './calculate-retry-delay.js';
import Options from './options.js';
import { isResponseOk } from './response.js';
import isClientRequest from './utils/is-client-request.js';
import isUnixSocketURL from './utils/is-unix-socket-url.js';
import {RequestError, ReadError, MaxRedirectsError, HTTPError, TimeoutError, UploadError, CacheError, AbortError} from './errors.js';
const supportsBrotli = is.string(process.versions.brotli);
const methodsWithoutX = new Set(['GET', 'HEAD']);
const cacheableStore = new WeakableMap();
const redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);
const proxiedRequestEvents = ['socket', 'connect', 'continue', 'information', 'upgrade'];
const noop = () => { };
export default class Request extends Duplex {
    ['constructor'];
    _noPipe;
    options;
    response;
    requestUrl;
    redirectUrls;
    retryCount;
    _stopRetry;
    _downloadedSize;
    _uploadedSize;
    _stopReading;
    _pipedServerResponses;
    _request;
    _responseSize;
    _xSize;
    _unproxyEvents;
    _isFromCache;
    _cannotHaveX;
    _triggerRead;
    _cancelTimeouts;
    _removeListeners;
    _nativeResponse;
    _flushed;
    _aborted;
    _requestInitialized;
    constructor(url, options, defaults) {
        super({autoDestroy: false, highWaterMark: 0});
        this._downloadedSize = 0;
        this._uploadedSize = 0;
        this._stopReading = false;
        this._pipedServerResponses = new Set();
        this._cannotHaveX = false;
        this._unproxyEvents = noop;
        this._triggerRead = false;
        this._cancelTimeouts = noop;
        this._removeListeners = noop;
        this._jobs = [];
        this._flushed = false;
        this._requestInitialized = false;
        this._aborted = false;
        this.redirectUrls = [];
        this.retryCount = 0;
        this._stopRetry = noop;
        this.on('pipe', (source) => {
            if (source?.headers) {
                Object.assign(this.options.headers, source.headers);
            }
        });
        this.on('newListener', event => {
            if (event === 'retry' && this.listenerCount('retry') > 0) {
                throw new Error('A retry listener has been attached already.');
            }
        });
        try {
            this.options = new Options(url, options, defaults);
            if (!this.options.url) {
                if (this.options.prefixUrl === '') {
                    throw new TypeError('Missing `url` property');
                }
                this.options.url = '';
            }
            this.requestUrl = this.options.url;
        }
        catch (error) {
            const { options } = error;
            if (options) {
                this.options = options;
            }
            this.flush = async () => {
                this.flush = async () => { };
                this.destroy(error);
            };
            return;
        }
        const { x } = this.options;
        if (is.nodeStream(x)) {
            x.once('error', error => {
                const handleError = () => this._beforeError(new UploadError(error, this));
                this._flushed 
                    ? handleError()
                    : this.flush = async () => {
                        this.flush = async () => {};
                        handleError();
                    };
            });
        }
        if (this.options.signal) {
            const abort = () => {
                this.destroy(
                    this.options.signal?.reason?.name === 'TimeoutError'
                        ? new TimeoutError(this.options.signal.reason, this.timings, this)
                        : new AbortError(this)
                );
            };
            if (this.options.signal.aborted) {
                abort();
            }
            else {
                this.options.signal.addEventListener('abort', abort);
                this._removeListeners = () => {
                    this.options.signal?.removeEventListener('abort', abort);
                };
            }
        }
    }
    async flush() {
        if (this._flushed) {
            return;
        }
        this._flushed = true;
        try {
            await this._finalizeX();
            if (this.destroyed) {
                return;
            }
            await this._makeRequest();
            if (this.destroyed) {
                this._request?.destroy();
                return;
            }
            for (const job of this._jobs) {
                job();
            }
            this._jobs.length = 0;
            this._requestInitialized = true;
        }
        catch (error) {
            this._beforeError(error);
        }
    }
    _beforeError(error) {
        if (this._stopReading) {
            return;
        }
        const { response, options } = this;
        const attemptCount = this.retryCount + (error.name === 'RetryError' ? 0 : 1);
        this._stopReading = true;
        if (!(error instanceof RequestError)) {
            error = new RequestError(error.message, error, this);
        }
        const typedError = error;
        void (async () => {
            if (response?.readable && !response.rawX && !this._request?.socket?.destroyed) {
                response.setEncoding(this.readableEncoding);
                const success = await this._setRawX(response);
                if (success) {
                    response.x = response.rawX.toString();
                }
            }
            if (this.listenerCount('retry') !== 0) {
                let backoff;
                try {
                    let retryAfter;
                    if (response && 'retry-after' in response.headers) {
                        retryAfter = Number(response.headers['retry-after']);
                        if (Number.isNaN(retryAfter)) {
                            retryAfter = Date.parse(response.headers['retry-after']) - Date.now();
                            if (retryAfter <= 0) {
                                retryAfter = 1;
                            }
                        }
                        else {
                            retryAfter *= 1000;
                        }
                    }
                    const retryOptions = options.retry;
                    backoff = await retryOptions.calculateDelay({
                        attemptCount,
                        retryOptions,
                        error: typedError,
                        retryAfter,
                        computedValue: calculateRetryDelay({
                            attemptCount,
                            retryOptions,
                            error: typedError,
                            retryAfter,
                            computedValue: retryOptions.maxRetryAfter ?? options.timeout.request ?? Number.POSITIVE_INFINITY,
                        }),
                    });
                }
                catch (error_) {
                    void this._error(new RequestError(error_.message, error_, this));
                    return;
                }
                if (backoff) {
                    await new Promise(resolve => {
                        const timeout = setTimeout(resolve, backoff);
                        this._stopRetry = () => {
                            clearTimeout(timeout);
                            resolve();
                        };
                    });
                    if (this.destroyed) {
                        return;
                    }
                    try {
                        for (const hook of this.options.hooks.beforeRetry) {
                            await hook(typedError, this.retryCount + 1);
                        }
                    }
                    catch (error_) {
                        void this._error(new RequestError(error_.message, error, this));
                        return;
                    }
                    if (this.destroyed) {
                        return;
                    }
                    this.destroy();
                    this.emit('retry', this.retryCount + 1, error, (updatedOptions) => {
                        const request = new Request(options.url, updatedOptions, options);
                        request.retryCount = this.retryCount + 1;
                        process.nextTick(() => {
                            void request.flush();
                        });
                        return request;
                    });
                    return;
                }
            }
            void this._error(typedError);
        })();
    }
    _read() {
        this._triggerRead = true;
        const { response } = this;
        if (response && !this._stopReading) {
            if (response.readableLength) {
                this._triggerRead = false;
            }
            let data;
            while ((data = response.read()) !== null) {
                this._downloadedSize += data.length;
                const progress = this.downloadProgress;
                if (progress.percent < 1) {
                    this.emit('downloadProgress', progress);
                }
                this.push(data);
            }
        }
    }
    _write(chunk, encoding, callback) {
        const write = () => this._writeRequest(chunk, encoding, callback);
        this._requestInitialized ? write() : this._jobs.push(write);
    }
    _final(callback) {
        const endRequest = () => {
            if (!this._request || this._request.destroyed) {
                callback();
                return;
            }

            this._request.end((error) => {
                if (this._request?._writableState?.errored) {
                    return;
                }
                if (!error) {
                    this._xSize = this._uploadedSize;
                    this.emit('uploadProgress', this.uploadProgress);
                    this._request.emit('upload-complete');
                }
                callback(error);
            });
        };
        this._requestInitialized ? endRequest() : this._jobs.push(endRequest);
    }
    _destroy(error, callback) {
        this._stopReading = true;
        this.flush = async () => { };
        this._stopRetry();
        this._cancelTimeouts();
        this._removeListeners();
        if (this.options) {
            const { x } = this.options;
            if (is.nodeStream(x)) {
                x.destroy();
            }
        }
        if (this._request) {
            this._request.destroy();
        }
        if (error !== null && !is.undefined(error) && !(error instanceof RequestError)) {
            error = new RequestError(error.message, error, this);
        }
        callback(error);
    }
    pipe(destination, options) {
        if (destination instanceof ServerResponse) {
            this._pipedServerResponses.add(destination);
        }
        return super.pipe(destination, options);
    }
    unpipe(destination) {
        if (destination instanceof ServerResponse) {
            this._pipedServerResponses.delete(destination);
        }
        super.unpipe(destination);
        return this;
    }
    async _finalizeX() {
        const { options } = this;
        const { headers } = options;
        const isForm = !is.undefined(options.form);
        const isJSON = !is.undefined(options.json);
        const isX = !is.undefined(options.x);
        const cannotHaveX = methodsWithoutX.has(options.method) && !(options.method === 'GET' && options.allowGetX);
        this._cannotHaveX = cannotHaveX;
        if (isForm || isJSON || isX) {
            if (cannotHaveX) {
                throw new TypeError(`The \`${options.method}\` method cannot be used with a x`);
            }
            const noContentType = !is.string(headers['content-type']);
            if (isX) {
                if (isFormDataLike(options.x)) {
                    const encoder = new FormDataEncoder(options.x);
                    if (noContentType) {
                        headers['content-type'] = encoder.headers['Content-Type'];
                    }
                    if ('Content-Length' in encoder.headers) {
                        headers['content-length'] = encoder.headers['Content-Length'];
                    }
                    options.x = encoder.encode();
                }
                if (isFormData(options.x) && noContentType) {
                    headers['content-type'] = `multipart/form-data; boundary=${options.x.getBoundary()}`;
                }
            }
            else if (isForm) {
                if (noContentType) {
                    headers['content-type'] = 'application/x-www-form-urlencoded';
                }
                const { form } = options;
                options.form = undefined;
                options.x = (new URLSearchParams(form)).toString();
            }
            else {
                if (noContentType) {
                    headers['content-type'] = 'application/json';
                }
                const { json } = options;
                options.json = undefined;
                options.x = options.stringifyJson(json);
            }
            const uploadXSize = await getXSize(options.x, options.headers);
            if (is.undefined(headers['content-length']) && is.undefined(headers['transfer-encoding']) && !cannotHaveX && !is.undefined(uploadXSize)) {
                headers['content-length'] = String(uploadXSize);
            }
        }
        if (options.responseType === 'json' && !('accept' in options.headers)) {
            options.headers.accept = 'application/json';
        }
        this._xSize = Number(headers['content-length']) || undefined;
    }
    async _onResponseBase(response) {
        if (this.isAborted) {
            return;
        }
        const { options } = this;
        const { url } = options;
        this._nativeResponse = response;
        if (options.decompress) {
            response = decompressResponse(response);
        }
        const statusCode = response.statusCode;
        const typedResponse = response;
        typedResponse.statusMessage = typedResponse.statusMessage ?? http.STATUS_CODES[statusCode];
        typedResponse.url = options.url.toString();
        typedResponse.requestUrl = this.requestUrl;
        typedResponse.redirectUrls = this.redirectUrls;
        typedResponse.request = this;
        typedResponse.isFromCache = this._nativeResponse.fromCache ?? false;
        typedResponse.ip = this.ip;
        typedResponse.retryCount = this.retryCount;
        typedResponse.ok = isResponseOk(typedResponse);
        this._isFromCache = typedResponse.isFromCache;
        this._responseSize = Number(response.headers['content-length']) || undefined;
        this.response = typedResponse;
        response.once('end', () => {
            this._responseSize = this._downloadedSize;
            this.emit('downloadProgress', this.downloadProgress);
        });
        response.once('error', (error) => {
            this._aborted = true;
            response.destroy();
            this._beforeError(new ReadError(error, this));
        });
        response.once('aborted', () => {
            this._aborted = true;
            this._beforeError(new ReadError({
                name: 'Error',
                message: 'The server aborted pending request',
                code: 'ECONNRESET',
            }, this));
        });
        this.emit('downloadProgress', this.downloadProgress);
        const rawCookies = response.headers['set-cookie'];
        if (is.object(options.cookieJar) && rawCookies) {
            let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));
            if (options.ignoreInvalidCookies) {
                promises = promises.map(async (promise) => {
                    try {
                        await promise;
                    }
                    catch { }
                });
            }
            try {
                await Promise.all(promises);
            }
            catch (error) {
                this._beforeError(error);
                return;
            }
        }
        if (this.isAborted) {
            return;
        }
        if (response.headers.location && redirectCodes.has(statusCode)) {
            const shouldFollow = typeof options.followRedirect === 'function' ? options.followRedirect(typedResponse) : options.followRedirect;
            if (shouldFollow) {
                response.resume();
                this._cancelTimeouts();
                this._unproxyEvents();
                if (this.redirectUrls.length >= options.maxRedirects) {
                    this._beforeError(new MaxRedirectsError(this));
                    return;
                }
                this._request = undefined;
                const updatedOptions = new Options(undefined, undefined, this.options);
                const serverRequestedGet = statusCode === 303 && updatedOptions.method !== 'GET' && updatedOptions.method !== 'HEAD';
                const canRewrite = statusCode !== 307 && statusCode !== 308;
                const userRequestedGet = updatedOptions.methodRewriting && canRewrite;
                if (serverRequestedGet || userRequestedGet) {
                    updatedOptions.method = 'GET';
                    updatedOptions.x = undefined;
                    updatedOptions.json = undefined;
                    updatedOptions.form = undefined;
                    delete updatedOptions.headers['content-length'];
                }
                try {
                    const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();
                    const redirectUrl = new URL(redirectBuffer, url);
                    if (!isUnixSocketURL(url) && isUnixSocketURL(redirectUrl)) {
                        this._beforeError(new RequestError('Cannot redirect to UNIX socket', {}, this));
                        return;
                    }
                    if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {
                        if ('host' in updatedOptions.headers) {
                            delete updatedOptions.headers.host;
                        }
                        if ('cookie' in updatedOptions.headers) {
                            delete updatedOptions.headers.cookie;
                        }
                        if ('authorization' in updatedOptions.headers) {
                            delete updatedOptions.headers.authorization;
                        }
                        if (updatedOptions.username || updatedOptions.password) {
                            updatedOptions.username = '';
                            updatedOptions.password = '';
                        }
                    }
                    else {
                        redirectUrl.username = updatedOptions.username;
                        redirectUrl.password = updatedOptions.password;
                    }
                    this.redirectUrls.push(redirectUrl);
                    updatedOptions.prefixUrl = '';
                    updatedOptions.url = redirectUrl;
                    for (const hook of updatedOptions.hooks.beforeRedirect) {
                        await hook(updatedOptions, typedResponse);
                    }
                    this.emit('redirect', updatedOptions, typedResponse);
                    this.options = updatedOptions;
                    await this._makeRequest();
                }
                catch (error) {
                    this._beforeError(error);
                    return;
                }
                return;
            }
        }
        if (options.isStream && options.throwHttpErrors && !isResponseOk(typedResponse)) {
            this._beforeError(new HTTPError(typedResponse));
            return;
        }
        response.on('readable', () => {
            if (this._triggerRead) {
                this._read();
            }
        });
        this.on('resume', () => { response.resume(); });
        this.on('pause', () => { response.pause(); });
        response.once('end', () => { this.push(null); });
        if (this._noPipe) {
            const success = await this._setRawX();
            if (success) {
                this.emit('response', response);
            }
            return;
        }
        this.emit('response', response);
        for (const destination of this._pipedServerResponses) {
            if (destination.headersSent) {
                continue;
            }
            for (const key in response.headers) {
                const isAllowed = options.decompress ? key !== 'content-encoding' : true;
                const value = response.headers[key];
                if (isAllowed) {
                    destination.setHeader(key, value);
                }
            }
            destination.statusCode = statusCode;
        }
    }
    async _setRawX(from = this) {
        if (from.readableEnded) {
            return false;
        }
        try {
            const fromArray = await from.toArray();
            const rawX = isBuffer(fromArray.at(0))
                ? Buffer.concat(fromArray)
                : Buffer.from(fromArray.join(''));
            if (!this.isAborted) {
                this.response.rawX = rawX;
                return true;
            }
        }
        catch { }
        return false;
    }
    async _onResponse(response) {
        await this._onResponseBase(response)
            .catch((error) => {
                this._beforeError(error);
            });
    }
    _onRequest(request) {
        const { options } = this;
        const { timeout, url } = options;
        timer(request);
        if (this.options.http2) {
            request.setTimeout(0);
        }
        this._cancelTimeouts = timedOut(request, timeout, url);
        const responseEventName = options.cache ? 'cacheableResponse' : 'response';
        request.once(responseEventName, (response) => {
            void this._onResponse(response);
        });
        request.once('error', (error) => {
            this._aborted = true;
            request.destroy();
            error = error instanceof TimedOutTimeoutError
                ? new TimeoutError(error, this.timings, this)
                : new RequestError(error.message, error, this);
            this._beforeError(error);
        });
        this._unproxyEvents = proxyEvents(request, this, proxiedRequestEvents);
        this._request = request;
        this.emit('uploadProgress', this.uploadProgress);
        this._sendX();
        this.emit('request', request);
    }
    async _asyncWrite(chunk) {
        return new Promise((resolve, reject) => {
            super.write(chunk, error => {
                if (error) {
                    reject(error);
                    return;
                }
                resolve();
            });
        });
    }
    _sendX() {
        const { x } = this.options;
        const currentRequest = this.redirectUrls.length === 0 ? this : this._request ?? this;
        if (is.nodeStream(x)) {
            x.pipe(currentRequest);
        }
        else if (is.generator(x) || is.asyncGenerator(x)) {
            (async () => {
                try {
                    for await (const chunk of x) {
                        await this._asyncWrite(chunk);
                    }
                    super.end();
                }
                catch (error) {
                    this._beforeError(error);
                }
            })();
        }
        else if (!is.undefined(x)) {
            this._writeRequest(x, undefined, () => { });
            currentRequest.end();
        }
        else if (this._cannotHaveX || this._noPipe) {
            currentRequest.end();
        }
    }
    _prepareCache(cache) {
        if (!cacheableStore.has(cache)) {
            const cacheableRequest = new CacheableRequest(((requestOptions, handler) => {
                const result = requestOptions._request(requestOptions, handler);
                if (is.promise(result)) {
                    result.once = (event, handler) => {
                        if (event === 'error') {
                            (async () => {
                                try {
                                    await result;
                                }
                                catch (error) {
                                    handler(error);
                                }
                            })();
                        }
                        else if (event === 'abort' || event === 'destroy') {
                            (async () => {
                                try {
                                    const request = (await result);
                                    request.once(event, handler);
                                }
                                catch { }
                            })();
                        }
                        else {
                            throw new Error(`Unknown HTTP2 promise event: ${event}`);
                        }
                        return result;
                    };
                }
                return result;
            }), cache);
            cacheableStore.set(cache, cacheableRequest.request());
        }
    }
    async _createCacheableRequest(url, options) {
        return new Promise((resolve, reject) => {
            Object.assign(options, urlToOptions(url));
            let request;
            const cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {
                response._readableState.autoDestroy = false;
                if (request) {
                    const fix = () => {
                        if (response.req) {
                            response.complete = response.req.res.complete;
                        }
                    };
                    response.prependOnceListener('end', fix);
                    fix();
                    (await request).emit('cacheableResponse', response);
                }
                resolve(response);
            });
            cacheRequest.once('error', reject);
            cacheRequest.once('request', async (requestOrPromise) => {
                request = requestOrPromise;
                resolve(request);
            });
        });
    }
    async _makeRequest() {
        const { options } = this;
        const { headers, username, password } = options;
        const cookieJar = options.cookieJar;
        for (const key in headers) {
            if (is.undefined(headers[key])) {
                delete headers[key];
            }
            else if (is.null(headers[key])) {
                throw new TypeError(`Use \`undefined\` instead of \`null\` to delete the \`${key}\` header`);
            }
        }
        if (options.decompress && is.undefined(headers['accept-encoding'])) {
            headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';
        }
        if (username || password) {
            const credentials = Buffer.from(`${username}:${password}`).toString('base64');
            headers.authorization = `Basic ${credentials}`;
        }
        if (cookieJar) {
            const cookieString = await cookieJar.getCookieString(options.url.toString());
            if (is.nonEmptyString(cookieString)) {
                headers.cookie = cookieString;
            }
        }
        options.prefixUrl = '';
        let request;
        for (const hook of options.hooks.beforeRequest) {
            const result = await hook(options);
            if (!is.undefined(result)) {
                request = () => result;
                break;
            }
        }
        request ||= options.getRequestFunction();
        const url = options.url;
        this._requestOptions = options.createNativeRequestOptions();
        if (options.cache) {
            this._requestOptions._request = request;
            this._requestOptions.cache = options.cache;
            this._requestOptions.x = options.x;
            this._prepareCache(options.cache);
        }
        const function_ = options.cache ? this._createCacheableRequest : request;
        try {
            let requestOrResponse = function_(url, this._requestOptions);
            if (is.promise(requestOrResponse)) {
                requestOrResponse = await requestOrResponse;
            }
            if (is.undefined(requestOrResponse)) {
                requestOrResponse = options.getFallbackRequestFunction()(url, this._requestOptions);
                if (is.promise(requestOrResponse)) {
                    requestOrResponse = await requestOrResponse;
                }
            }
            if (isClientRequest(requestOrResponse)) {
                this._onRequest(requestOrResponse);
            }
            else if (this.writable) {
                this.once('finish', () => {
                    void this._onResponse(requestOrResponse);
                });
                this._sendX();
            }
            else {
                void this._onResponse(requestOrResponse);
            }
        }
        catch (error) {
            if (error instanceof CacheableCacheError) {
                throw new CacheError(error, this);
            }
            throw error;
        }
    }
    async _error(error) {
        try {
            if (error instanceof HTTPError && !this.options.throwHttpErrors) {
                // This branch can be reached only when using the Promise API
                // Skip calling the hooks on purpose.
                // See https://github.com/sindresorhus/got/issues/2103
            }
            else {
                for (const hook of this.options.hooks.beforeError) {
                    error = await hook(error);
                }
            }
        }
        catch (error_) {
            error = new RequestError(error_.message, error_, this);
        }
        this.destroy(error);
    }
    _writeRequest(chunk, encoding, callback) {
        if (!this._request || this._request.destroyed) {
            return;
        }
        this._request.write(chunk, encoding, (error) => {
            if (!error && !this._request.destroyed) {
                this._uploadedSize += Buffer.byteLength(chunk, encoding);
                const progress = this.uploadProgress;
                if (progress.percent < 1) {
                    this.emit('uploadProgress', progress);
                }
            }
            callback(error);
        });
    }
    get ip() { return this.socket?.remoteAddress; }
    get isAborted() { return this._aborted; }
    get socket() { return this._request?.socket ?? undefined; }
    get downloadProgress() {
        const percent = this._responseSize
            ? this._downloadedSize / this._responseSize
            : this._responseSize === this._downloadedSize
                ? 1
                : 0;
        return {
            percent,
            transferred: this._downloadedSize,
            total: this._responseSize,
        };
    }
    get uploadProgress() {
        const percent = this._xSize
            ? this._uploadedSize / this._xSize
            : this._xSize === this._uploadedSize
                ? 1
                : 0;
        return {
            percent,
            transferred: this._uploadedSize,
            total: this._xSize,
        };
    }
    get timings() { return this._request?.timings; }
    get isFromCache() { return this._isFromCache; }
    get reusedSocket() { return this._request?.reusedSocket; }
}