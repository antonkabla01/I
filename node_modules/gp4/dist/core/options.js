import process from 'node:process';
import { promisify, inspect } from 'node:util';
import { checkServerIdentity } from 'node:tls';
import https from 'node:https';
import http from 'node:http';
import is, { assert } from '@sindresorhus/is';
import lowercaseKeys from 'lowercase-keys';
import CacheableLookup from 'cacheable-lookup';
import http2wrapper from 'http2-wrapper';
import { isFormData } from 'form-data-encoder';
import parseLinkHeader from './parse-link-header.js';
const [major, minor] = process.versions.node.split('.').map(Number);
function validateSearchParameters(searchParameters) {
    for (const key in searchParameters) {
        const value = searchParameters[key];
        assert.any([is.string, is.number, is.boolean, is.null, is.undefined], value);
    }
}
const globalCache = new Map();
let globalDnsCache;
const getGlobalDnsCache = () => {
    if (globalDnsCache) {
        return globalDnsCache;
    }
    globalDnsCache = new CacheableLookup();
    return globalDnsCache;
};
const defaultInternals = {
    request: undefined,
    agent: {
        http: undefined,
        https: undefined,
        http2: undefined,
    },
    h2session: undefined,
    decompress: true,
    timeout: {
        connect: undefined,
        lookup: undefined,
        read: undefined,
        request: undefined,
        response: undefined,
        secureConnect: undefined,
        send: undefined,
        socket: undefined,
    },
    prefixUrl: '',
    x: undefined,
    form: undefined,
    json: undefined,
    cookieJar: undefined,
    ignoreInvalidCookies: false,
    searchParams: undefined,
    dnsLookup: undefined,
    dnsCache: undefined,
    context: {},
    hooks: {
        init: [],
        beforeRequest: [],
        beforeError: [],
        beforeRedirect: [],
        beforeRetry: [],
        afterResponse: [],
    },
    followRedirect: true,
    maxRedirects: 10,
    cache: undefined,
    throwHttpErrors: true,
    username: '',
    password: '',
    http2: false,
    allowGetX: false,
    headers: {
        'user-agent': 'Gp4Client/1.0',
    },
    methodRewriting: false,
    dnsLookupIpVersion: undefined,
    parseJson: JSON.parse,
    stringifyJson: JSON.stringify,
    retry: {
        limit: 2,
        methods: [
            'GET',
            'PUT',
            'HEAD',
            'DELETE',
            'OPTIONS',
            'TRACE',
        ],
        statusCodes: [
            408,
            413,
            429,
            500,
            502,
            503,
            504,
            521,
            522,
            524,
        ],
        errorCodes: [
            'ETIMEDOUT',
            'ECONNRESET',
            'EADDRINUSE',
            'ECONNREFUSED',
            'EPIPE',
            'ENOTFOUND',
            'ENETUNREACH',
            'EAI_AGAIN',
        ],
        maxRetryAfter: undefined,
        calculateDelay: ({ computedValue }) => computedValue,
        backoffLimit: Number.POSITIVE_INFINITY,
        noise: 100,
    },
    localAddress: undefined,
    method: 'GET',
    createConnection: undefined,
    cacheOptions: {
        shared: undefined,
        cacheHeuristic: undefined,
        immutableMinTimeToLive: undefined,
        ignoreCargoCult: undefined,
    },
    https: {
        alpnProtocols: undefined,
        rejectUnauthorized: undefined,
        checkServerIdentity: undefined,
        certificateAuthority: undefined,
        key: undefined,
        certificate: undefined,
        passphrase: undefined,
        pfx: undefined,
        ciphers: undefined,
        honorCipherOrder: undefined,
        minVersion: undefined,
        maxVersion: undefined,
        signatureAlgorithms: undefined,
        tlsSessionLifetime: undefined,
        dhparam: undefined,
        ecdhCurve: undefined,
        certificateRevocationLists: undefined,
    },
    encoding: undefined,
    resolveXOnly: false,
    isStream: false,
    skipDecode: false,
    encode: false,
    responseType: 'text',
    url: undefined,
    pagination: {
        transform(response) {
            if (response.request.options.responseType === 'json') {
                return response.x;
            }
            return JSON.parse(response.x);
        },
        paginate({ response }) {
            const rawLinkHeader = response.headers.link;
            if (typeof rawLinkHeader !== 'string' || rawLinkHeader.trim() === '') {
                return false;
            }
            const parsed = parseLinkHeader(rawLinkHeader);
            const next = parsed.find(entry => entry.parameters.rel === 'next' || entry.parameters.rel === '"next"');
            if (next) {
                return {
                    url: new URL(next.reference, response.url),
                };
            }
            return false;
        },
        filter: () => true,
        shouldContinue: () => true,
        countLimit: Number.POSITIVE_INFINITY,
        backoff: 0,
        requestLimit: 10_000,
        stackAllItems: false,
    },
    setHost: true,
    maxHeaderSize: undefined,
    signal: undefined,
    enableUnixSockets: false,
};
const cloneInternals = (internals) => {
    const { hooks, retry } = internals;
    const result = {
        ...internals,
        context: { ...internals.context },
        cacheOptions: { ...internals.cacheOptions },
        https: { ...internals.https },
        agent: { ...internals.agent },
        headers: { ...internals.headers },
        retry: {
            ...retry,
            errorCodes: [...retry.errorCodes],
            methods: [...retry.methods],
            statusCodes: [...retry.statusCodes],
        },
        timeout: { ...internals.timeout },
        hooks: {
            init: [...hooks.init],
            beforeRequest: [...hooks.beforeRequest],
            beforeError: [...hooks.beforeError],
            beforeRedirect: [...hooks.beforeRedirect],
            beforeRetry: [...hooks.beforeRetry],
            afterResponse: [...hooks.afterResponse],
        },
        searchParams: internals.searchParams ? new URLSearchParams(internals.searchParams) : undefined,
        pagination: { ...internals.pagination },
    };
    if (result.url !== undefined) {
        result.prefixUrl = '';
    }
    return result;
};
const cloneRaw = (raw) => {
    const { hooks, retry } = raw;
    const result = { ...raw };
    if (is.object(raw.context)) {
        result.context = { ...raw.context };
    }
    if (is.object(raw.cacheOptions)) {
        result.cacheOptions = { ...raw.cacheOptions };
    }
    if (is.object(raw.https)) {
        result.https = { ...raw.https };
    }
    if (is.object(raw.cacheOptions)) {
        result.cacheOptions = { ...result.cacheOptions };
    }
    if (is.object(raw.agent)) {
        result.agent = { ...raw.agent };
    }
    if (is.object(raw.headers)) {
        result.headers = { ...raw.headers };
    }
    if (is.object(retry)) {
        result.retry = { ...retry };
        if (is.array(retry.errorCodes)) {
            result.retry.errorCodes = [...retry.errorCodes];
        }
        if (is.array(retry.methods)) {
            result.retry.methods = [...retry.methods];
        }
        if (is.array(retry.statusCodes)) {
            result.retry.statusCodes = [...retry.statusCodes];
        }
    }
    if (is.object(raw.timeout)) {
        result.timeout = { ...raw.timeout };
    }
    if (is.object(hooks)) {
        result.hooks = {
            ...hooks,
        };
        if (is.array(hooks.init)) {
            result.hooks.init = [...hooks.init];
        }
        if (is.array(hooks.beforeRequest)) {
            result.hooks.beforeRequest = [...hooks.beforeRequest];
        }
        if (is.array(hooks.beforeError)) {
            result.hooks.beforeError = [...hooks.beforeError];
        }
        if (is.array(hooks.beforeRedirect)) {
            result.hooks.beforeRedirect = [...hooks.beforeRedirect];
        }
        if (is.array(hooks.beforeRetry)) {
            result.hooks.beforeRetry = [...hooks.beforeRetry];
        }
        if (is.array(hooks.afterResponse)) {
            result.hooks.afterResponse = [...hooks.afterResponse];
        }
    }
    if (is.object(raw.pagination)) {
        result.pagination = { ...raw.pagination };
    }
    return result;
};
const getHttp2TimeoutOption = (internals) => {
    const delays = [internals.timeout.socket, internals.timeout.connect, internals.timeout.lookup, internals.timeout.request, internals.timeout.secureConnect].filter(delay => typeof delay === 'number');
    if (delays.length > 0) {
        return Math.min(...delays);
    }
    return undefined;
};
const init = (options, withOptions, self) => {
    const initHooks = options.hooks?.init;
    if (initHooks) {
        for (const hook of initHooks) {
            hook(withOptions, self);
        }
    }
};
export default class Options {
    _unixOptions;
    _internals;
    _merging;
    _init;
    constructor(input, options, defaults) {
        assert.any([is.string, is.urlInstance, is.object, is.undefined], input);
        assert.any([is.object, is.undefined], options);
        assert.any([is.object, is.undefined], defaults);
        if (input instanceof Options || options instanceof Options) {
            throw new TypeError('The defaults must be passed as the third argument');
        }
        this._internals = cloneInternals(defaults?._internals ?? defaults ?? defaultInternals);
        this._init = [...(defaults?._init ?? [])];
        this._merging = false;
        this._unixOptions = undefined;
        try {
            if (is.plainObject(input)) {
                try {
                    this.merge(input);
                    this.merge(options);
                }
                finally {
                    this.url = input.url;
                }
            }
            else {
                try {
                    this.merge(options);
                }
                finally {
                    if (options?.url !== undefined) {
                        if (input === undefined) {
                            this.url = options.url;
                        }
                        else {
                            throw new TypeError('The `url` option is mutually exclusive with the `input` argument');
                        }
                    }
                    else if (input !== undefined) {
                        this.url = input;
                    }
                }
            }
        }
        catch (error) {
            error.options = this;
            throw error;
        }
    }
    merge(options) {
        if (!options) {
            return;
        }
        if (options instanceof Options) {
            for (const init of options._init) {
                this.merge(init);
            }
            return;
        }
        options = cloneRaw(options);
        init(this, options, this);
        init(options, options, this);
        this._merging = true;
        if ('isStream' in options) {
            this.isStream = options.isStream;
        }
        try {
            let push = false;
            for (const key in options) {
                if (key === 'mutableDefaults' || key === 'handlers') {
                    continue;
                }
                if (key === 'url') {
                    continue;
                }
                if (!(key in this)) {
                    throw new Error(`Unexpected option: ${key}`);
                }
                const value = options[key];
                if (value === undefined) {
                    continue;
                }
                this[key] = value;
                push = true;
            }
            if (push) {
                this._init.push(options);
            }
        }
        finally {
            this._merging = false;
        }
    }

    get request() {
        return this._internals.request;
    }

    set request(value) {
        assert.any([is.function, is.undefined], value);
        this._internals.request = value;
    }

    get agent() {
        return this._internals.agent;
    }

    set agent(value) {
        assert.plainObject(value);
        for (const key in value) {
            if (!(key in this._internals.agent)) {
                throw new TypeError(`Unexpected agent option: ${key}`);
            }
            assert.any([is.object, is.undefined], value[key]);
        }
        this._internals.agent = this._merging
            ? { ...this._internals.agent, ...value }
            : { ...value };
    }

    get h2session() {
        return this._internals.h2session;
    }

    set h2session(value) {
        this._internals.h2session = value;
    }

    get decompress() {
        return this._internals.decompress;
    }

    set decompress(value) {
        assert.boolean(value);
        this._internals.decompress = value;
    }

    get timeout() {
        return this._internals.timeout;
    }

    set timeout(value) {
        assert.plainObject(value);
        for (const key in value) {
            if (!(key in this._internals.timeout)) {
                throw new Error(`Unexpected timeout option: ${key}`);
            }
            assert.any([is.number, is.undefined], value[key]);
        }
        this._internals.timeout = this._merging
            ? { ...this._internals.timeout, ...value }
            : { ...value };
    }

    get prefixUrl() {
        return this._internals.prefixUrl;
    }

    set prefixUrl(value) {
        assert.any([is.string, is.urlInstance], value);
        if (value === '') {
            this._internals.prefixUrl = '';
            return;
        }
        value = value.toString();
        if (!value.endsWith('/')) {
            value += '/';
        }
        if (this._internals.prefixUrl && this._internals.url) {
            const { href } = this._internals.url;
            this._internals.url.href = value + href.slice(this._internals.prefixUrl.length);
        }
        this._internals.prefixUrl = value;
    }

    get x() {
        return this._internals.x;
    }

    set x(value) {
        assert.any([is.string, is.buffer, is.nodeStream, is.generator, is.asyncGenerator, isFormData, is.undefined], value);
        if (is.nodeStream(value)) {
            assert.truthy(value.readable);
        }
        if (value !== undefined) {
            assert.undefined(this._internals.form);
            assert.undefined(this._internals.json);
        }
        this._internals.x = value;
    }

    get form() {
        return this._internals.form;
    }

    set form(value) {
        assert.any([is.plainObject, is.undefined], value);
        if (value !== undefined) {
            assert.undefined(this._internals.x);
            assert.undefined(this._internals.json);
        }
        this._internals.form = value;
    }

    get json() {
        return this._internals.json;
    }

    set json(value) {
        if (value !== undefined) {
            assert.undefined(this._internals.x);
            assert.undefined(this._internals.form);
        }
        this._internals.json = value;
    }

    get url() {
        return this._internals.url;
    }

    set url(value) {
        assert.any([is.string, is.urlInstance, is.undefined], value);
        if (value === undefined) {
            this._internals.url = undefined;
            return;
        }
        if (is.string(value) && value.startsWith('/')) {
            throw new Error('`url` must not start with a slash');
        }
        const urlString = `${this.prefixUrl}${value.toString()}`;
        const url = new URL(urlString);
        this._internals.url = url;
        if (url.protocol === 'unix:') {
            url.href = `http://unix${url.pathname}${url.search}`;
        }
        if (url.protocol !== 'http:' && url.protocol !== 'https:') {
            const error = new Error(`Unsupported protocol: ${url.protocol}`);
            error.code = 'ERR_UNSUPPORTED_PROTOCOL';
            throw error;
        }
        if (this._internals.username) {
            url.username = this._internals.username;
            this._internals.username = '';
        }
        if (this._internals.password) {
            url.password = this._internals.password;
            this._internals.password = '';
        }
        if (this._internals.searchParams) {
            url.search = this._internals.searchParams.toString();
            this._internals.searchParams = undefined;
        }
        if (url.hostname === 'unix') {
            if (!this._internals.enableUnixSockets) {
                throw new Error('Using UNIX domain sockets but option `enableUnixSockets` is not enabled');
            }
            const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);
            if (matches?.groups) {
                const { socketPath, path } = matches.groups;
                this._unixOptions = {
                    socketPath,
                    path,
                    host: '',
                };
            }
            else {
                this._unixOptions = undefined;
            }
            return;
        }
        this._unixOptions = undefined;
    }

    get cookieJar() {
        return this._internals.cookieJar;
    }

    set cookieJar(value) {
        assert.any([is.object, is.undefined], value);
        if (value === undefined) {
            this._internals.cookieJar = undefined;
            return;
        }
        let { setCookie, getCookieString } = value;
        assert.function(setCookie);
        assert.function(getCookieString);
        if (setCookie.length === 4 && getCookieString.length === 0) {
            setCookie = promisify(setCookie.bind(value));
            getCookieString = promisify(getCookieString.bind(value));
            this._internals.cookieJar = {
                setCookie,
                getCookieString: getCookieString,
            };
        }
        else {
            this._internals.cookieJar = value;
        }
    }

    get signal() {
        return this._internals.signal;
    }

    set signal(value) {
        assert.object(value);
        this._internals.signal = value;
    }

    get ignoreInvalidCookies() {
        return this._internals.ignoreInvalidCookies;
    }

    set ignoreInvalidCookies(value) {
        assert.boolean(value);
        this._internals.ignoreInvalidCookies = value;
    }

    get searchParams() {
        if (this._internals.url) {
            return this._internals.url.searchParams;
        }
        if (this._internals.searchParams === undefined) {
            this._internals.searchParams = new URLSearchParams();
        }
        return this._internals.searchParams;
    }

    set searchParams(value) {
        assert.any([is.string, is.object, is.undefined], value);
        const url = this._internals.url;
        if (value === undefined) {
            this._internals.searchParams = undefined;
            if (url) {
                url.search = '';
            }
            return;
        }
        const searchParameters = this.searchParams;
        let updated;
        if (is.string(value)) {
            updated = new URLSearchParams(value);
        }
        else if (value instanceof URLSearchParams) {
            updated = value;
        }
        else {
            validateSearchParameters(value);
            updated = new URLSearchParams();
            for (const key in value) {
                const entry = value[key];
                if (entry === null) {
                    updated.append(key, '');
                }
                else if (entry === undefined) {
                    searchParameters.delete(key);
                }
                else {
                    updated.append(key, entry);
                }
            }
        }
        if (this._merging) {
            for (const key of updated.keys()) {
                searchParameters.delete(key);
            }
            for (const [key, value] of updated) {
                searchParameters.append(key, value);
            }
        }
        else if (url) {
            url.search = searchParameters.toString();
        }
        else {
            this._internals.searchParams = searchParameters;
        }
    }

    get searchParameters() {
        throw new Error('The `searchParameters` option does not exist. Use `searchParams` instead.');
    }

    set searchParameters(_value) {
        throw new Error('The `searchParameters` option does not exist. Use `searchParams` instead.');
    }

    get dnsLookup() {
        return this._internals.dnsLookup;
    }

    set dnsLookup(value) {
        assert.any([is.function, is.undefined], value);
        this._internals.dnsLookup = value;
    }

    get dnsCache() {
        return this._internals.dnsCache;
    }

    set dnsCache(value) {
        assert.any([is.object, is.boolean, is.undefined], value);
        this._internals.dnsCache = value === true
            ? getGlobalDnsCache()
            : value === false
                ? undefined
                : value;
    }

    get context() {
        return this._internals.context;
    }

    set context(value) {
        assert.object(value);
        this._internals.context = this._merging
            ? { ...this._internals.context, ...value }
            : { ...value };
    }

    get hooks() {
        return this._internals.hooks;
    }

    set hooks(value) {
        assert.object(value);
        for (const knownHookEvent in value) {
            if (!(knownHookEvent in this._internals.hooks)) {
                throw new Error(`Unexpected hook event: ${knownHookEvent}`);
            }
            const typedKnownHookEvent = knownHookEvent;
            const hooks = value[typedKnownHookEvent];
            assert.any([is.array, is.undefined], hooks);
            if (hooks) {
                for (const hook of hooks) {
                    assert.function(hook);
                }
            }
            if (this._merging) {
                if (hooks) {
                    this._internals.hooks[typedKnownHookEvent].push(...hooks);
                }
            }
            else {
                if (!hooks) {
                    throw new Error(`Missing hook event: ${knownHookEvent}`);
                }
                this._internals.hooks[knownHookEvent] = [...hooks];
            }
        }
    }

    get followRedirect() {
        return this._internals.followRedirect;
    }

    set followRedirect(value) {
        assert.any([is.boolean, is.function], value);
        this._internals.followRedirect = value;
    }

    get followRedirects() {
        throw new TypeError('The `followRedirects` option does not exist. Use `followRedirect` instead.');
    }

    set followRedirects(_value) {
        throw new TypeError('The `followRedirects` option does not exist. Use `followRedirect` instead.');
    }

    get maxRedirects() {
        return this._internals.maxRedirects;
    }

    set maxRedirects(value) {
        assert.number(value);
        this._internals.maxRedirects = value;
    }

    get cache() {
        return this._internals.cache;
    }

    set cache(value) {
        assert.any([is.object, is.string, is.boolean, is.undefined], value);
        this._internals.cache = value === true
            ? globalCache
            : value === false
                ? undefined
                : value;
    }

    get throwHttpErrors() {
        return this._internals.throwHttpErrors;
    }

    set throwHttpErrors(value) {
        assert.boolean(value);
        this._internals.throwHttpErrors = value;
    }

    get username() {
        const value = this._internals.url?.username ?? this._internals.username;
        return decodeURIComponent(value);
    }

    set username(value) {
        assert.string(value);
        const fixedValue = encodeURIComponent(value);
        this._internals.url
            ? (this._internals.url.username = fixedValue)
            : (this._internals.username = fixedValue);
    }

    get password() {
        const value = this._internals.url?.password ?? this._internals.password;
        return decodeURIComponent(value);
    }

    set password(value) {
        assert.string(value);
        const fixedValue = encodeURIComponent(value);
        this._internals.url
            ? (this._internals.url.password = fixedValue)
            : (this._internals.password = fixedValue);
    }

    get http2() {
        return this._internals.http2;
    }

    set http2(value) {
        assert.boolean(value);
        this._internals.http2 = value;
    }

    get allowGetX() {
        return this._internals.allowGetX;
    }

    set allowGetX(value) {
        assert.boolean(value);
        this._internals.allowGetX = value;
    }

    get headers() {
        return this._internals.headers;
    }

    set headers(value) {
        assert.plainObject(value);
        this._internals.headers = this._merging
            ? { ...this._internals.headers, ...lowercaseKeys(value) }
            : lowercaseKeys(value);
    }

    get methodRewriting() {
        return this._internals.methodRewriting;
    }

    set methodRewriting(value) {
        assert.boolean(value);
        this._internals.methodRewriting = value;
    }

    get dnsLookupIpVersion() {
        return this._internals.dnsLookupIpVersion;
    }

    set dnsLookupIpVersion(value) {
        if (value !== undefined && value !== 4 && value !== 6) {
            throw new TypeError(`Invalid DNS lookup IP version: ${value}`);
        }
        this._internals.dnsLookupIpVersion = value;
    }

    get parseJson() {
        return this._internals.parseJson;
    }

    set parseJson(value) {
        assert.function(value);
        this._internals.parseJson = value;
    }

    get stringifyJson() {
        return this._internals.stringifyJson;
    }

    set stringifyJson(value) {
        assert.function(value);
        this._internals.stringifyJson = value;
    }

    get retry() {
        return this._internals.retry;
    }

    set retry(value) {
        assert.plainObject(value);
        assert.any([is.function, is.undefined], value.calculateDelay);
        assert.any([is.number, is.undefined], value.maxRetryAfter);
        assert.any([is.number, is.undefined], value.limit);
        assert.any([is.array, is.undefined], value.methods);
        assert.any([is.array, is.undefined], value.statusCodes);
        assert.any([is.array, is.undefined], value.errorCodes);
        assert.any([is.number, is.undefined], value.noise);
        value.noise && Math.abs(value.noise) > 100
            ? (() => { throw new Error(`The maximum acceptable retry noise is +/- 100ms, gp4 ${value.noise}`); })()
            : null;
        for (const key in value) {
            if (!(key in this._internals.retry)) {
                throw new Error(`Unexpected retry option: ${key}`);
            }
        }
        this._internals.retry = this._merging
            ? Object.assign(this._internals.retry, value)
            : { ...value };
        const { retry } = this._internals;
        retry.methods = [...new Set(retry.methods.map(method => method.toUpperCase()))];
        retry.statusCodes = [...new Set(retry.statusCodes)];
        retry.errorCodes = [...new Set(retry.errorCodes)];
    }

    get localAddress() {
        return this._internals.localAddress;
    }

    set localAddress(value) {
        assert.any([is.string, is.undefined], value);
        this._internals.localAddress = value;
    }

    get method() {
        return this._internals.method;
    }

    set method(value) {
        assert.string(value);
        this._internals.method = value.toUpperCase();
    }

    get createConnection() {
        return this._internals.createConnection;
    }

    set createConnection(value) {
        assert.any([is.function, is.undefined], value);
        this._internals.createConnection = value;
    }

    get cacheOptions() {
        return this._internals.cacheOptions;
    }

    set cacheOptions(value) {
        assert.plainObject(value);
        assert.any([is.boolean, is.undefined], value.shared);
        assert.any([is.number, is.undefined], value.cacheHeuristic);
        assert.any([is.number, is.undefined], value.immutableMinTimeToLive);
        assert.any([is.boolean, is.undefined], value.ignoreCargoCult);    
        for (const key in value) {
            if (!(key in this._internals.cacheOptions)) {
                throw new Error(`Cache option \`${key}\` does not exist`);
            }
        }
        this._internals.cacheOptions = this._merging
            ? { ...this._internals.cacheOptions, ...value }
            : { ...value };
    }

    get https() {
        return this._internals.https;
    }

    get skipDecode() {
        return this._internals.skipDecode;
    }

    set skipDecode(value) {
        this._internals.skipDecode = value === true;
    }

    set https(value) {
        assert.plainObject(value);
        assert.any([is.boolean, is.undefined], value.rejectUnauthorized);
        assert.any([is.function, is.undefined], value.checkServerIdentity);
        assert.any([is.string, is.object, is.array, is.undefined], value.certificateAuthority);
        assert.any([is.string, is.object, is.array, is.undefined], value.key);
        assert.any([is.string, is.object, is.array, is.undefined], value.certificate);
        assert.any([is.string, is.undefined], value.passphrase);
        assert.any([is.string, is.buffer, is.array, is.undefined], value.pfx);
        assert.any([is.array, is.undefined], value.alpnProtocols);
        assert.any([is.string, is.undefined], value.ciphers);
        assert.any([is.string, is.buffer, is.undefined], value.dhparam);
        assert.any([is.string, is.undefined], value.signatureAlgorithms);
        assert.any([is.string, is.undefined], value.minVersion);
        assert.any([is.string, is.undefined], value.maxVersion);
        assert.any([is.boolean, is.undefined], value.honorCipherOrder);
        assert.any([is.number, is.undefined], value.tlsSessionLifetime);
        assert.any([is.string, is.undefined], value.ecdhCurve);
        assert.any([is.string, is.buffer, is.array, is.undefined], value.certificateRevocationLists);
        for (const key in value) {
            if (!(key in this._internals.https)) {
                throw new Error(`HTTPS option \`${key}\` does not exist`);
            }
        }
        this._internals.https = this._merging
            ? { ...this._internals.https, ...value }
            : { ...value };
    }

    get encoding() {
        return this._internals.encoding;
    }

    set encoding(value) {
        if (value === null) {
            throw new TypeError('To get a Buffer, set `options.responseType` to `buffer` instead');
        }
        assert.any([is.string, is.undefined], value);
        this._internals.encoding = value;
    }

    get resolveXOnly() {
        return this._internals.resolveXOnly;
    }

    set resolveXOnly(value) {
        assert.boolean(value);
        this._internals.resolveXOnly = value;
    }

    get isStream() {
        return this._internals.isStream;
    }

    set isStream(value) {
        assert.boolean(value);
        this._internals.isStream = value;
    }

    get responseType() {
        return this._internals.responseType;
    }

    set responseType(value) {
        this._internals.responseType = value === undefined
            ? 'text'
            : (value !== 'text' && value !== 'buffer' && value !== 'json')
                ? (() => { throw new Error(`Invalid \`responseType\` option: ${value}\nValue: \`text\` \`buffer\` \`json\``); })()
                : value;
    }

    get pagination() {
        return this._internals.pagination;
    }

    set pagination(value) {
        assert.object(value);
        this._internals.pagination = this._merging
            ? { ...this._internals.pagination, ...value }
            : { ...value }
    }

    get auth() {
        throw new Error('Parameter `auth` is deprecated. Use `username` / `password` instead.');
    }

    set auth(_value) {
        throw new Error('Parameter `auth` is deprecated. Use `username` / `password` instead.');
    }

    get setHost() {
        return this._internals.setHost;
    }

    set setHost(value) {
        assert.boolean(value);
        this._internals.setHost = value;
    }

    get maxHeaderSize() {
        return this._internals.maxHeaderSize;
    }

    set maxHeaderSize(value) {
        assert.any([is.number, is.undefined], value);
        this._internals.maxHeaderSize = value;
    }

    get enableUnixSockets() {
        return this._internals.enableUnixSockets;
    }

    set enableUnixSockets(value) {
        assert.boolean(value);
        this._internals.enableUnixSockets = value;
    }

    toJSON() {
        return { ...this._internals };
    }

    [Symbol.for('nodejs.util.inspect.custom')](_depth, options) {
        return inspect(this._internals, options);
    }

    createNativeRequestOptions() {
        const internals = this._internals;
        const url = internals.url;
        const agent = url.protocol === 'https:'
            ? internals.http2
                ? internals.agent
                : internals.agent.https
            : internals.agent.http;
        const { https } = internals;
        let { pfx } = https;
        if (is.array(pfx) && is.plainObject(pfx[0])) {
            pfx = pfx.map(object => ({
                buf: object.buffer,
                passphrase: object.passphrase,
            }));
        }
        return {
            ...internals.cacheOptions,
            ...this._unixOptions,
            ALPNProtocols: https.alpnProtocols,
            ca: https.certificateAuthority,
            cert: https.certificate,
            key: https.key,
            passphrase: https.passphrase,
            pfx: https.pfx,
            rejectUnauthorized: https.rejectUnauthorized,
            checkServerIdentity: https.checkServerIdentity ?? checkServerIdentity,
            ciphers: https.ciphers,
            honorCipherOrder: https.honorCipherOrder,
            minVersion: https.minVersion,
            maxVersion: https.maxVersion,
            sigalgs: https.signatureAlgorithms,
            sessionTimeout: https.tlsSessionLifetime,
            dhparam: https.dhparam,
            ecdhCurve: https.ecdhCurve,
            crl: https.certificateRevocationLists,
            lookup: internals.dnsLookup ?? internals.dnsCache?.lookup,
            family: internals.dnsLookupIpVersion,
            agent,
            setHost: internals.setHost,
            method: internals.method,
            maxHeaderSize: internals.maxHeaderSize,
            localAddress: internals.localAddress,
            headers: internals.headers,
            createConnection: internals.createConnection,
            timeout: internals.http2 ? getHttp2TimeoutOption(internals) : undefined,
            h2session: internals.h2session,
        };
    }

    getRequestFunction() {
        const url = this._internals.url;
        const { request } = this._internals;
        if (!request && url) {
            return this.getFallbackRequestFunction();
        }
        return request;
    }

    getFallbackRequestFunction() {
        const url = this._internals.url;
        if (!url) {
            return;
        }
        if (url.protocol === 'https:') {
            if (this._internals.http2) {
                if (major < 15 || (major === 15 && minor < 10)) {
                    const error = new Error('To use the `http2` option, install Node.js 15.10.0 or above');
                    error.code = 'EUNSUPPORTED';
                    throw error;
                }
                return http2wrapper.auto;
            }
            return https.request;
        }
        return http.request;
    }

    freeze() {
        const options = this._internals;
        Object.freeze(options);
        Object.freeze(options.hooks);
        Object.freeze(options.hooks.afterResponse);
        Object.freeze(options.hooks.beforeError);
        Object.freeze(options.hooks.beforeRedirect);
        Object.freeze(options.hooks.beforeRequest);
        Object.freeze(options.hooks.beforeRetry);
        Object.freeze(options.hooks.init);
        Object.freeze(options.https);
        Object.freeze(options.cacheOptions);
        Object.freeze(options.agent);
        Object.freeze(options.headers);
        Object.freeze(options.timeout);
        Object.freeze(options.retry);
        Object.freeze(options.retry.errorCodes);
        Object.freeze(options.retry.methods);
        Object.freeze(options.retry.statusCodes);
    }
}
