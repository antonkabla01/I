import { RequestError } from './errors.js';
import { decode } from './utils/decode.js';
export const isResponseOk = (response) => {
   const { statusCode } = response;
   const { followRedirect } = response.request.options;
   const shouldFollow = typeof followRedirect === 'function' ? followRedirect(response) : followRedirect;
   const limitStatusCode = shouldFollow ? 299 : 399;
   return (statusCode >= 200 && statusCode <= limitStatusCode) || statusCode === 304;
};
export class ParseError extends RequestError {
   constructor(error, response) {
      const { options } = response.request;
      super(`${error.message} in "${options.url.toString()}"`, error, response.request);
      this.name = 'ParseError';
      this.code = 'ERR_X_PARSE_FAILURE';
   }
}
export const parseX = (response, responseType, parseJson, encoding, skipDecode = false) => {
    const { rawX } = response;
    const x = decode(rawX.toString(encoding)) ?? rawX.toString(encoding);
    try {
        if (skipDecode) return rawX.toString(encoding);
        if (responseType === 'text') return x;
        if (responseType === 'json') return parseJson(x);
        if (responseType === 'buffer') return rawX;
    }
    catch (e) {
        throw new ParseError(e, response);
    }
    throw new ParseError({
        message: `Unknown x type '${responseType}'`,
        name: 'Error',
    }, response);
};
