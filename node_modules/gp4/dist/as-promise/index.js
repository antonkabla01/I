import { EventEmitter } from 'node:events';
import is from '@sindresorhus/is';
import PCancelable from 'p-cancelable';
import { HTTPError, RetryError } from '../core/errors.js';
import Request from '../core/index.js';
import { parseX, isResponseOk, ParseError } from '../core/response.js';
import proxyEvents from '../core/utils/proxy-events.js';
import { CancelError } from './types.js';

const proxiedRequestEvents = ['request', 'response', 'redirect', 'uploadProgress', 'downloadProgress'];

const asPromise = (firstRequest) => {
    let globalRequest;
    let globalResponse;
    let normalizedOptions;
    const emitter = new EventEmitter();

    const promise = new PCancelable((resolve, reject, onCancel) => {
        onCancel(() => globalRequest?.destroy());
        onCancel.shouldReject = false;
        onCancel(() => reject(new CancelError(globalRequest)));

        const makeRequest = (retryCount) => {
            onCancel(() => {});
            const request = firstRequest ?? new Request(undefined, undefined, normalizedOptions);
            request.retryCount = retryCount;
            request._noPipe = true;
            globalRequest = request;

            request.once('response', async (response) => {
                const contentEncoding = (response.headers['content-encoding'] ?? '').toLowerCase();
                const isCompressed = ['gzip', 'deflate', 'br'].includes(contentEncoding);

                response.x = isCompressed && !request.options.decompress 
                    ? response.rawX 
                    : (() => {
                        try {
                            return parseX(response, request.options.responseType, request.options.parseJson, request.options.encoding, request.options.skipDecode);
                        }
                        catch (error) {
                            response.x = response.rawX.toString();
                            return isResponseOk(response) ? request._beforeError(error) : request._beforeError(new ParseError(error, response));
                        }
                    })();

                try {
                    for (const [index, hook] of request.options.hooks.afterResponse.entries()) {
                        response = await hook(response, async (updatedOptions) => {
                            request.options.merge(updatedOptions);
                            request.options.prefixUrl = '';
                            updatedOptions.url && (request.options.url = updatedOptions.url);
                            request.options.hooks.afterResponse = request.options.hooks.afterResponse.slice(0, index);
                            throw new RetryError(request);
                        });
                        if (!is.object(response) || !is.number(response.statusCode) || is.nullOrUndefined(response.x)) {
                            throw new TypeError('The `afterResponse` hook returned an invalid value');
                        }
                    }
                }
                catch (error) {
                    return request._beforeError(error);
                }

                globalResponse = response;
                !isResponseOk(response) 
                    ? request._beforeError(new HTTPError(response))
                    : (request.destroy(), resolve(request.options.resolveXOnly ? response.x : response));
            });

            const onError = (error) => promise.isCanceled 
                ? null 
                : error instanceof HTTPError && !request.options.throwHttpErrors 
                    ? (request.destroy(), resolve(request.options.resolveXOnly ? error.response.x : error.response))
                    : reject(error);

            request.once('error', onError);

            const previousX = request.options?.x;
            request.once('retry', (newRetryCount, error) => {
                firstRequest = undefined;
                previousX === request.options.x && is.nodeStream(request.options.x)
                    ? (error.message = 'Cannot retry with consumed x stream', onError(error))
                    : (normalizedOptions = request.options, makeRequest(newRetryCount));
            });

            proxyEvents(request, emitter, proxiedRequestEvents);
            is.undefined(firstRequest) && request.flush();
        };

        makeRequest(0);
    });

    promise.on = (event, fn) => (emitter.on(event, fn), promise);
    promise.off = (event, fn) => (emitter.off(event, fn), promise);

    const shortcut = (responseType) => Object.assign(
        (async () => parseX(
            await promise, 
            responseType, 
            globalResponse.request.options.parseJson, 
            globalResponse.request.options.encoding
        ))(),
        Object.getOwnPropertyDescriptors(promise)
    );

    promise.json = () => (
        globalRequest.options && !globalRequest.writableFinished && !('accept' in globalRequest.options.headers) 
            ? globalRequest.options.headers.accept = 'application/json' 
            : null,
        shortcut('json')
    );
    promise.buffer = () => shortcut('buffer');
    promise.text = () => shortcut('text');

    return promise;
}
export default asPromise;